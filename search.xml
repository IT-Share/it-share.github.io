<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Gallery Post]]></title>
    <url>%2F2017%2F09%2F16%2F1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记-1]]></title>
    <url>%2F2017%2F09%2F16%2Fnew%2F2016-07-02-study-of-python%2F</url>
    <content type="text"><![CDATA[基础语法数据结构list len() 求长度 a[i] list a 中第i个元素， a[2:9] 第2到9个元素，a[-1] 倒数第一个元素。 a.append(elem) list尾部追加一个元素 a.insert(i,elem) list第i个位置插入一个元素 a.pop(i) list 删除第i个元素，不指定i则默认删除最后一个 list的元素可以类型不同，也可以是list tupletuple不可变的元素集合，只有一个元素是的定义 a=(1,) 注意,是为了避免数学运算()的歧义 dict dict：key-value对，查询dict[key]可以取出对应的value。添加新键值对或修改值 dict[key]=newvalue。判断key是否存在 key in dict 或 dict.get(key,int-flag) 如果key不存在则返回指定的数值，不指定则返回none，none在交互式命令中不显示。删除一个key-value，用dict.pop(key) dict 插入查找速度快，占用内存多，list查找、插入与元素数量有关，占用内存空间少 set set： 也是一组key的集合，但是没有value set 初始化传入参数由一个list提供，s=set([1,1,2,2,3,4,5]),输出结果s为set([1,2,3,4,5])，其中的[]表示集合，重复元素被剔除，而不是list。 添加元素s.add(key),删除元素 s.remove(key) s1 &amp; s2 求交集；s1 | s2 ,求并集。 判断和循环 if 123456if x : # x非0非None即True xxxelif y: # 可以多个if嵌套使用 oooelse: xxoo for 123# xxxx为可迭代对象，list，dict，set和任何实现__next_item__方法的对象for x in xxxx: print x while 12345678# 当条件为真，执行循环while a&gt;0: a += 1 if a == 100: continue # a为100时跳过本次，进入下一层循环 if a &gt; 1000: # a为1000时跳过本次，跳出循环 break print a 函数 help(func) 查看函数fanc的帮助信息；dir(func)查看函数的内置方法；isinstance（x，（int,float））,类型检查； 定义函数 def myfunc(para1,para2): pass ;pass占位符，不知道写啥时可以先用它占位。 return x 返回x，没有return也会返回none，return可以返回多个值，但其本质是返回一个tuple。 默认参数放到后面，def power(x,n=2): pass;调用函数时默认参数如果不按顺序赋值，则需指定参数名。默认参数的值要设为不可变的变量类型，而不能是list。 可变参数，即输入的可以是0或多个参数不固定。定义可变参数仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此调用该函数时，可以传入任意个参数，包括0个参数。如果变量已经保存为list或tuple，则可以用 *list来传递参数，而不用list[0],list[1] … 那么麻烦； 1234def func(*numbers): for num in numbers : pass #numbers是一个tuple pass 关键字参数：允许传入0或多个带参数名的参数，在函数内部作为一个dict, 使用**para 表示关键字参数.调用函数时也可将dict转换为关键字参数传递进去，func（**dict） 12def student(name,age,**p_other): print name,age,p_other 组合参数：参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去，因此，对于任意函数，都可以通过类似func(args, *kw)的形式调用它，无论它的参数是如何定义的。 递归函数 注意栈溢出问题 Python高级特性切片切片 L[0:3] 或 L[:3] 取L的前三个元素,不包括3；L[-2:]取倒数后2个元素；L[:10:2] 前10个元素，每2个取一个；tuple或字符串也可以切片操作。 迭代迭代 for … in 实现遍历list或tuple或其他可迭代对象。默认情况下，dict迭代的是key，for key in d : pass。如果要迭代value，可以用for value in d.itervalues()，如果要同时迭代key和value，可以用for k, v in d.iteritems()。字符串也可以迭代，for ch in ‘ABC’: print ch。 for循环中同时迭代索引和元素本身 12for i, value in enumerate(['A', 'B', 'C']): print i, value 列表生成式快速创建list，简单强大。 12345678range(1,11) ;[x * x for x in range(1,11)] =[1,4,9,...,100] ;[x * x for x in range(1,11) if x%2==0] = [4,16,36,64,100] ; # 两层循环 [x + y for x in 'ABC' for y in 'ZXD' ]; # 列出当前目录下的文件和目录：import os[d d in os.listdir('.')] 生成器像不生成完整的list，而采用一边循环一边计算的机制；创建方法1： 将列表生成式的[]改为() g=(x * x for x in range(10)) 如果要一个一个打印出来g的元素，可以通过generator的next()方法，但是通常用for迭代来遍历。 for n in g: print g 方法2：通过函数实现生成器 123456def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b # generator在执行过程中，遇到yield就中断，下次又继续执行。 a, b = b, a + b n = n + 1 要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。 函数式编程高阶函数允许函数作为参数传入: 12def add(x, y, f): return f(x) + f(y) map/reduce map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。 123456def f(x): return x**2map(f, [1,2,3,4,5,6])# 输出 [1,4,9,16,25,36]map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])#输出 ['1', '2', '3', '4', '5', '6', '7', '8', '9'] reduce()把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算,例如，实现‘1 3 5 7 9’序列变为整数13579 1234def fn(x, y): return x*10 + yreduce(fn, [1, 3, 5, 7, 9])# 输出 13579 filter filter()也接收一个函数和一个序列。filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 123def is_odd(n): return n/2==1filter(is_odd,[1,2,3,4,5,6]) #求奇数 sorted Python内置的sorted()函数就可以对list进行排序。sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。比如实现倒序排序reversed_cmp函数 1234567891011sorted([36, 5, 12, 9, 21])# 输出 [5, 9, 12, 21, 36]def reversed_cmp(x, y): if x &gt; y: return -1 if x &lt; y: return 1 return 0 sorted([36, 5, 12, 9, 21], reversed_cmp)# 输出 [36, 21, 12, 9, 5] 返回函数匿名函数lambda当高阶函数的参数是传入函数时，可以不显示地定义函数，直接传入匿名函数： 12map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])# 输出 [1, 4, 9, 16, 25, 36, 49, 64, 81] 关键字lambda表示匿名函数，冒号前面的x表示函数参数。 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数. 装饰器假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。 123456789def log(func): def wrapper(*args, **kw): print 'call %s():' % func.__name__ return func(*args, **kw) return wrapper #定义如上，使用如下： @logdef now(): print '2013-12-25' 把@log放到now()函数的定义处，相当于执行了语句 now=log(now) 参考文章-python装饰器 偏函数functools模块的一个功能， 1int2 = functools.partial(int, base=2) int2函数就是int（n，base=2）导出的新函数，int()函数的默认base=10，但是int2也可以接收参数base=10；functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 模块package &gt; module &gt; func package:按目录结构来管理模块，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。 编写模块 1234567891011121314151617181920#!/usr/bin/env python# -*- coding: utf-8 -*-' a test module ' #任何模块代码的第一个字符串都被视为模块的文档注释；__author__ = 'Michael Liao'import sysdef test(): args = sys.argv #用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，运行python hello.py Michael获得的sys.argv就是['hello.py', 'Michael]。 if len(args)==1: print 'Hello, world!' elif len(args)==2: print 'Hello, %s!' % args[1] else: print 'Too many arguments!'if __name__=='__main__': test() 导入模块 123456789try: import cStringIO as StringIO #使用别名except ImportError: # 导入失败会捕获到ImportError import StringIO# 常见用法try: import json # python &gt;= 2.6except ImportError: import simplejson as json # python &lt;= 2.5 模块中__xx__这样的变量或函数是有特殊用途的，比如__doc__,一般自己的不要这样定义。 模块中_XX或__xx是私有函数或变量，不能直接引用。外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。 安装第三方模块 pip install module-namepip install wheel Scrapy pymongo requests celery -i http://pypi.douban.com/simple --trusted-host pypi.douban.com-i 指定源，—-trusted-host 添加域名信任 导入模块时，默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中 123import syssys.path# 输出 ['', '/Library/Python/2.7/site-packages/pycrypto-2.6.1-py2.7-macosx-10.9-intel.egg', '/Library/Python/2.7/site-packages/PIL-1.1.7-py2.7-macosx-10.9-intel.egg', ...] 如果我们要添加自己的搜索目录，有两种方法：一是运行时修改sys.path，添加要搜索的目录：sys.path.append(‘/user/module/path’) ，运行结束后失效。 第二种在系统中设置环境变量“PYTHONPATH” 面向对象编程类和实例面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同,和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。 1234567class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print '%s: %s' % (self.__name, self.__score) (object)，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 类的初始化方法init,传进的第一个参数是self，表示实例自身。创建实例时必须传入与init一致的变量，self除外。 属性方法和访问限制class内的属性前加上__就会变成私有变量，外部无法访问,获取或修改私有变量可以创建方法get set等，在方法中可以对参数进行检查。 类的属性仅对当前类起作用，对继承的子类是不起作用的,除非在子类中也定义__slots__，这样，子类允许定义的属性就是自身的__slots__加上父类的__slots__。 12345678910111213141516171819202122232425class Student(object): passs=Student()s.name='abc' #为一个实例添加属性，对其他实例无效 def set_age(self,age): self.age=agefrom types import MethodTypes.set_age = MethodType(set_age, s, Student) # 给实例绑定一个方法s.set_age(25)print s.age #为对象绑定一个方法def set_score(self,score): self.score=scoreStudent.set_score=MethodType(set_score,None,Student)# 如果我们想要限制class的属性怎么办？比如，只允许对Student实例添加name和age属性。# 为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class能添加的属性：class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称#__slots__定义的属性仅对当前类起作用，对继承的子类是不起作用的,除非在子类中也定义__slots__，这样，子类允许定义的属性就是自身的__slots__加上父类的__slots__。 有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢?Python内置的@property装饰器就是负责把一个方法变成属性调用的. 12345678910111213class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value 继承和多态继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写； 多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal类的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：对扩展开放：允许新增Animal子类；对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 123def run_twice(animal): #animal是Animal类对象的一个实例 animal.run() animal.run() 获取对象信息获取对象类型用函数type(),模块types里保存了所有的type类型常量。 123import typesprint type('abc') == types.StringType# output: True 使用isinstance(x,y)判断的是x对象是否是y类型本身，或者位于y类型的父继承链上。 dir() 获取一个对象的所有方法和属性，返回一个list。 getattr()、setattr()访问设置对象属性，hasattr() 可以测试对象的属性是否存在。 1234def readImage(fp): if hasattr(fp, 'read'): return readData(fp) return None 多重继承class dog(Mammal, Runnable): pass ,使用多继承可以避免复杂庞大的继承链。 定制类__xxx__的变量或者函数名在Python中是有特殊用途的,__slots__是为了限制类的属性，__len__()方法是为了能让class作用于len()函数。__str__()方法，打印实例；如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。要表现得像list那样按照下标取出元素，需要实现__getitem__()方法；__getattr__()方法，动态返回一个属性，如果找不到引用的属性，则用该方法动态返回 更多可定制属性参考python官方文档 元类参考博客]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[python基础教程资源合集]]></title>
    <url>%2F2017%2F07%2F16%2Fpython%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[分享几个Python新手入门的视频教程,同样适合零编程基础的同学。 python3完全零基础入门视频 出处不详 【课程简介】#### 【课程内容】 计算机基础常识 Python语言概览、安装与运行 Python 变量、数据类型及存储 Python 常用数据类型概览 数值与字符串 列表list 字典表dict 与元组 tuple 文件与类型汇总 语句、表达式与if分支 循环语句 迭代 函数定义与参数 函数与Lambda表达式 函数应用与工具 包与模块管理及面向对象初步 面向对象编程OOP 异常处理及测试 unittest单元测试 数值、日期与时间 对象持久化 字符与编码 正则表达式 系统编程 python并行编程 函数高级应用及装饰器 Python-SublimeText-Python-配置 虚拟环境配置-csv文件读取处理 JSON-Excel 数据文件处理 Python 操作SQLite 【下载地址】​ 百度网盘 链接 密码: xk5d 零基础入门学python(42课全) 小甲鱼 鱼C 出品的教程，关于python3的零基础学习，共42课时。 【课程简介】 【课程内容】 【下载地址】​ 百度网盘 链接 密码: meze 网易云python入门教程 网易云的python编程入门公开课，哈尔滨工业大学出品。非常适合新手。 【课程简介】讲的挺好的 【课程内容】 【下载地址】​ 百度网盘 链接 密码: zzay python魔鬼训练营系列教程 魔鬼训练营系列，适合懂python基础语法的同学进阶学习 【课程简介】 本课程主要针对python常用的一些知识点，疑难点进行拆分并单独讲解；每一个课程都会对具体的知识点先进行学习，然后在举一个具体的例子来实践当次课程的内容；使得每一个知识点都可以更加牢固的掌握。本课程的内容包括从python基础、python的表达式、数据结构等基础知识，还包括迭代器、包装器等高级功能，还有正则表达式、xml、Excel等工作中常用的第三方类库的使用讲解，以及一些web应用的第三方类库的使用。课程中包含的内容覆盖了我们日常工作中常用的大部分内容，学完之后可以给我们的工作带来实质性的的帮助。 本系列课程的形式与一般的基础课程不同，每次课主要由若干个例子，以及若干道有一定难度的习题组成，需要较多的动手练习，讲师每次课讲解例题，以及上周课的习题讲解，如果有需要了解的背景知识，会穿插在题目讲解中。“做题控”们不妨加入，让自己的能力通过反复迭代的学习逐渐臻于化境。 授课对象：本课程适合对python略有了解，希望巩固python基础，更深入掌握python，了解高级特性和第三方类库的同学们。 课程环境：windows + pycharm 或 Linux + vim 【课程内容】第一课：python入门指引python的基础知识，快速入门 第二课：数据结构的正确使用姿势元组、列表、字典等数据结构的使用 第三课：表达式的魅力讲解python表达式的运用 第四课：重新结实老朋友yield讲解yield的作用和应用 第五课：闭包的前世今生讲解闭包和包装器的使用 第六课：线程与进程的故事python线程和进程的应用 第七课：使用正则找到金子正则表达式的应用 第八课：与数据库们的第一次亲密接触如何连接各种数据库并使用 第九课：XML就该这么用xml模块的快速使用 第十课：你也可以轻松玩转EXCELExcel模块的使用 第十一课：一只来自网页上的爬虫爬虫程序的开发过程 第十二课：有一种网页叫博客web站点的开发过程 【下载地址】​ 百度网盘 链接 密码: fb9s]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>基础教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test1]]></title>
    <url>%2F2017%2F07%2F11%2Ftest1%2F</url>
    <content type="text"><![CDATA[测试这是个测试]]></content>
      <tags>
        <tag>test1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World2]]></title>
    <url>%2F2017%2F07%2F11%2Fmy_index%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>c1</category>
        <category>c2</category>
      </categories>
      <tags>
        <tag>test1</tag>
        <tag>test2</tag>
      </tags>
  </entry>
</search>